import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

import org.antlr.v4.runtime.misc.NotNull;
import org.antlr.v4.runtime.tree.ErrorNode;
import org.antlr.v4.runtime.tree.ParseTree;
import org.antlr.v4.runtime.tree.RuleNode;
import org.antlr.v4.runtime.tree.TerminalNode;



public class WACCVisitor extends BasicParserBaseVisitor<Type> {
	
	private SymbolTable TOP_ST; 
	HashMap<String, Function> functions;
	
	
	@Override
    public Type visitProgram(BasicParser.ProgramContext ctx) {
        TOP_ST = new SymbolTable(null);
        for (BasicParser.FuncContext func : ctx.func()) {
            List<Type> params = new ArrayList<Type>();
            if (func.paramlist() != null) {
                for (BasicParser.ParamContext l : func.paramlist().param()) {
                    params.add(visit(l.type()));
                }
            }
            functions.put(func.IDENT().getText(), new Function(visit(func.type()), params));
        }
        return visitChildren(ctx);
    }


    @Override
    public Type visitFunc(BasicParser.FuncContext ctx) {
        SymbolTable symboltable1 = new SymbolTable(TOP_ST);
        TOP_ST = symboltable1;
        if (ctx.paramlist() != null) {
            visit(ctx.paramlist());
            SymbolTable symboltable2 = new SymbolTable(symboltable1);
            TOP_ST = symboltable2;
            visit(ctx.stat());
            TOP_ST = TOP_ST.getParent().getParent();
        }
        return PrimType.NULL;
        
    }
    
    @Override
    public Type visitParam(BasicParser.ParamContext ctx) {
        Type t = visit(ctx.type());
        TOP_ST.add(ctx.IDENT().getText(), t);
        return t;
    }
    
    @Override 
    public Type visitExp_assignrhs(@NotNull BasicParser.Exp_assignrhsContext ctx) { 
        return visit(ctx.expr()); 
    }

    @Override
    public Type visitArrayLiter_assignrhs(@NotNull BasicParser.ArrayLiter_assignrhsContext ctx) { 
        return visit(ctx.arrayliter()); 
    }
    
    @Override 
    public Type visitPairElem_assignrhs(@NotNull BasicParser.PairElem_assignrhsContext ctx) { 
        return visit(ctx.pairelem());
@Override 
    public Type visitCall_assignrhs(@NotNull BasicParser.Call_assignrhsContext ctx) { 
        if (!functions.containsKey(ctx.IDENT().getText())){
            System.err.println("Function not defined");
            System.exit(200);
        }
        return PrimType.NULL;
    }
    
    @Override 
    public Type visitBaseType_type(@NotNull BasicParser.BaseType_typeContext ctx) { 
        return visit(ctx.basetype());
    }
@Override 
    public Type visitInt_baseType(@NotNull BasicParser.Int_baseTypeContext ctx) { 
        return PrimType.INT;
    }
    
    @Override 
    public Type visitBool_baseType(@NotNull BasicParser.Bool_baseTypeContext ctx) { 
        return PrimType.BOOL;
    }
    
    @Override 
    public Type visitChar_baseType(@NotNull BasicParser.Char_baseTypeContext ctx) { 
        return PrimType.CHAR;
    }
    
    @Override 
    public Type visitString_baseType(@NotNull BasicParser.String_baseTypeContext ctx) { 
        return PrimType.STRING;
    }
    
    @Override 
    public Type visitIdentEq_Stat(@NotNull BasicParser.IdentEq_StatContext ctx) {
        Type type1 = visit(ctx.type());
        Type type2 = visit(ctx.assignrhs());
        if (type1.isOfType(type2)) {
            String id = ctx.IDENT().getText();
            if (TOP_ST.lookUpCurrLevelAndEnclosingLevels(id) != null) {
                TOP_ST.add(ctx.IDENT().getText(), type1);
            }
            System.err.println("Identifier already declared: " + id);
            System.exit(200);
        }
        System.err.println("Mismatched types. Expected: " + type1 + "Actual: " + type2);
        System.exit(200);
        return null;
    }
    
    @Override 
    public Type visitRead_Stat(@NotNull BasicParser.Read_StatContext ctx) { 
         Type t = visit(ctx.assignlhs());
         if (!(t.isOfType(PrimType.CHAR) || t.isOfType(PrimType.INT)
             ||t.isOfType(PrimType.STRING))) {
             System.err.println("Cannot read. Type is invalid");
             System.exit(200);
         }
         return null;
    }
    
    @Override 
    public Type visitBegin_Stat(@NotNull BasicParser.Begin_StatContext ctx) { 
        SymbolTable symbolTable1 = new SymbolTable(TOP_ST);
        TOP_ST = symbolTable1;
        visit(ctx.stat());
        TOP_ST = TOP_ST.getParent();
        return null;
    }
    
    @Override 
    public Type visitAssignLhsRhs_Stat(@NotNull BasicParser.AssignLhsRhs_StatContext ctx) {
        Type lhs = visit(ctx.assignlhs());
        Type rhs = visit(ctx.assignrhs());
        if (!lhs.isOfType(rhs)) {
            System.err.println("Mismatched types of lhs: " + lhs + " and rhs: " + rhs);
            System.exit(200);
        }
        return null;
    }
    
    @Override 
    public Type visitFree_Stat(@NotNull BasicParser.Free_StatContext ctx) { 
        Type t = visit(ctx.expr());
        if (!(t instanceof ArrayType || t instanceof PairType)) {
            System.err.println("Incorrect type. Must be of arraytype or pairtype. Actual type: " 
                    + t);
            System.exit(200);
        }
        return null;
    }
@Override 
    public Type visitIdent_AssignLhs(@NotNull BasicParser.Ident_AssignLhsContext ctx) {
        String id = ctx.IDENT().getText();
        Type type = TOP_ST.lookUpCurrLevelAndEnclosingLevels(id);
        if (type == null) {
            System.err.println("The identifier " + id + "not declared");
            System.exit(200);
        }
        return type;
    }
@Override 
    public Type visitExit_Stat(@NotNull BasicParser.Exit_StatContext ctx) { 
        Type t = visit(ctx.expr());
        if (t != PrimType.INT) {
            System.err.println("Expected type: Int, Actual type: " + t);
            System.exit(200);
        }
        return null;
    }
    
    @Override 
    public Type visitPrint_Stat(@NotNull BasicParser.Print_StatContext ctx) { 
        return visit(ctx.expr());
    }
    
    @Override 
    public Type visitPrintln_Stat(@NotNull BasicParser.Println_StatContext ctx) { 
        return visit(ctx.expr());
    }
    
    @Override
    public Type visitSemicolon_Stat(@NotNull BasicParser.Semicolon_StatContext ctx) {
        visit(ctx.stat(0));
        visit(ctx.stat(1));
        return null;
    }
    
    @Override 
    public Type visitIf_Stat(@NotNull BasicParser.If_StatContext ctx) { 
        Type t = visit(ctx.expr());
        if (t == PrimType.BOOL) {
            SymbolTable sym1 = new SymbolTable(TOP_ST);
            TOP_ST = sym1;
            visit(ctx.stat(0));
            TOP_ST = TOP_ST.getParent();
            SymbolTable sym2 = new SymbolTable(TOP_ST);
            TOP_ST = sym2;
            visit(ctx.stat(1));
            TOP_ST = TOP_ST.getParent();
        }
        System.err.println("Expression does not resolve to a Bool Type. Actual type: " + t);
        System.exit(200); 
        return null;
    }
    
    @Override 
    public Type visitWhile_Stat(@NotNull BasicParser.While_StatContext ctx) {
        Type t = visit(ctx.expr());
        if (t == PrimType.BOOL) {
            SymbolTable sym1 = new SymbolTable(TOP_ST);
            TOP_ST = sym1;
            visit(ctx.stat());
            TOP_ST = TOP_ST.getParent();
        }
        System.err.println("Expression does not resolve to a Bool Type. Actual type: " + t);
        System.exit(200); 
        return null;
    }



//////////////////////////////// TOLAâ€™S HALF //////////////////////////////////////////////////////



    
    @Override
    public Type visitBaseType_type(@NotNull BasicParser.BaseType_typeContext ctx) {
        return visit(ctx.basetype());
    }
    
    @Override
    Type visitArrayType_type(@NotNull BasicParser.ArrayType_typeContext ctx) {
        return visit(ctx.arraytype());
    }
    
    @Override
    public Type visitPairType_type(@NotNull BasicParser.PairType_typeContext ctx) {
        return visit(ctx.pairtype());
    }
    

    @Override
    public Type visitBaseType_arrayType(@NotNull BasicParser.BaseType_arrayTypeContext ctx) {
        return visit(ctx.basetype());
    }
    
    @Override
    public Type visitArrayType_arrayType(@NotNull BasicParser.ArrayType_arrayTypeContext ctx) {
        return visit(ctx.arraytype());
    }
    
    @Override
    public Type visitPairType_arrayType(@NotNull BasicParser.PairType_arrayTypeContext ctx) {
        return visit(ctx.pairtype());
    }
    
    @Override
    public Type visitUnaryOper_Expr(@NotNull BasicParser.UnaryOper_ExprContext ctx) {
        visit(ctx.unaryoper());
        visit(ctx.expr());
        return Type.NULL;

    }

    @Override
    public Type visitParenth_Expr(@NotNull BasicParser.Parenth_ExprContext ctx) {
        return visit(ctx.expr());
    }

    @Override
    public Type visitFactor_Expr(@NotNull BasicParser.Factor_ExprContext ctx) {
        visit(ctx.expr(0));
        visit(ctx.factor());
        return visit(ctx.expr(1));
    }


    /*

    @Override

    public Type visitFactor_Expr(@NotNull BasicParser.Factor_ExprContext ctx) {

    if (visit(ctx.expr(0)) == Type.INT && visit(ctx.expr(1)) == Type.INT) {

    return Type.INT;

    } else System.exit(200); return Type.ERROR;

    }

    */

    @Override
    public Type visitTerm_Expr(@NotNull BasicParser.Term_ExprContext ctx) {
        visit(ctx.expr(0));
        visit(ctx.term());
        return visit(ctx.expr(1));
    }

    /*

    * @Override

    public Type visitTerm_Expr(@NotNull BasicParser.Term_ExprContext ctx) {

    return visitChildren(ctx);

    }

    */

    @Override
    public Type visitArrayElem_Expr(@NotNull BasicParser.ArrayElem_ExprContext ctx) {
        SymbolTable st = new SymbolTable(TOP_ST);
        st.add(ctx.arrayelem().IDENT().getText(), new Array(visit(ctx.arrayelem())));
        return visit(ctx.arrayelem());
    }

    @Override
        public Type visitUnaryoper(@NotNull BasicParser.UnaryoperContext ctx) {
        return Type.NULL;
    }

    @Override
    public Type visitFactor(@NotNull BasicParser.FactorContext ctx) {
        switch (ctx.start.getType()) {
        case BasicParser.MUL : return Type.MUL;
        case BasicParser.DIV : return Type.DIV;
        case BasicParser.MOD : return Type.MOD;
        default : System.exit(200); return Type.ERROR;
        }
    }

    @Override
    public Type visitBool_Liter(@NotNull BasicParser.Bool_LiterContext ctx) {
        if (ctx.start.getType() == BasicParser.TRUE) {
            return Type.TRUE;
        } else if (ctx.start.getType() == BasicParser.FALSE) {
            return Type.FALSE;
        } else {
            return Type.ERROR;
        }
    }

    @Override
    public Type visitTerm(@NotNull BasicParser.TermContext ctx) {
        switch (ctx.start.getType()) {
            case BasicParser.PLUS  : return Type.PLUS;
            case BasicParser.MINUS : return Type.MINUS;
            case BasicParser.GRT   : return Type.GRT;
            case BasicParser.GRTEQ : return Type.GRTEQ;
            case BasicParser.SMT   : return Type.SMT;
            case BasicParser.EQEQ  : return Type.EQEQ;
            case BasicParser.SMTEQ : return Type.SMTEQ;
            case BasicParser.NOTEQ : return Type.NOTEQ;
            case BasicParser.AND   : return Type.AND;
            case BasicParser.OR    : return Type.OR;
            default                : System.exit(200); return Type.ERROR;
         }
    }


    @Override

    public Type visitArrayelem(@NotNull BasicParser.ArrayelemContext ctx) {
        Type t = visit(ctx.expr());
        TOP_ST.add(ctx.IDENT().getText(), new Array(t));
        return visit(ctx.expr());
    }


    @Override
    public Type visitArrayliter(@NotNull BasicParser.ArrayliterContext ctx) {
        if (ctx.getChild(1) instanceof BasicParser.ArglistContext) {
            visit(ctx.arglist());
        }   
        return Type.NULL;    
    }
    
    @Override
    public Type visitNewPair_assignrhs(@NotNull BasicParser.NewPair_assignrhsContext ctx) {
        return null;
    }
    
    
    @Override
    public Type visitInt_baseType(@NotNull BasicParser.Int_baseTypeContext ctx) {
        return Type.INT;
    }
    
    @Override
    public Type visitBool_baseType(@NotNull BasicParser.Bool_baseTypeContext ctx) {
        return Type.BOOL;
    }
    
    @Override
    public Type visitChar_baseType(@NotNull BasicParser.Char_baseTypeContext ctx) {
        return Type.CHAR;
    }
    
    @Override
    public Type visitString_baseType(@NotNull BasicParser.String_baseTypeContext ctx) {
        return Type.STRING;
    }
    
    @Override
    public Type visitSkip_Stat(@NotNull BasicParser.Skip_StatContext ctx) {
        return Type.SKIP;
    }
    
    @Override
    public Type visitBegin_Stat(@NotNull BasicParser.Begin_StatContext ctx) {
        return visit(ctx.stat());
    }
    
    @Override
    public Type visitFree_Stat(@NotNull BasicParser.Free_StatContext ctx) {
        if (visit(ctx.expr()) != Type.INT) {
            System.exit(200);
        }
        return Type.ERROR;
    }
    
    @Override
    public Type visitReturn_Stat(@NotNull BasicParser.Return_StatContext ctx) {
        return visit(ctx.expr());
    }
    
    @Override
    public Type visitExit_Stat(@NotNull BasicParser.Exit_StatContext ctx) {
        if (visit(ctx.expr()) != Type.INT) {
            System.exit(200);
        }
        return Type.ERROR;
    }
    
    @Override
    public Type visitPrint_Stat(@NotNull BasicParser.Print_StatContext ctx) {
        return visit(ctx.expr());
    }
    
    @Override
    public Type visitPrintln_Stat(@NotNull BasicParser.Println_StatContext ctx) {
        return visit(ctx.expr());
    }
    
    @Override
    public Type visitSemicolon_Stat(@NotNull BasicParser.Semicolon_StatContext ctx) {
        visit(ctx.stat(0));
        visit(ctx.stat(1));
        return Type.ERROR;
    }
    
    @Override
    public Type visitIf_Stat(@NotNull BasicParser.If_StatContext ctx) {
        if (visit(ctx.expr()) == Type.BOOL) {
            return Type.BOOL;
        }
        System.exit(200); return Type.ERROR;
    }
    
    @Override
    public Type visitWhile_Stat(@NotNull BasicParser.While_StatContext ctx) {
        if (visit(ctx.expr()) == Type.BOOL) {
            return visit(ctx.stat());
        }
        System.exit(200); return Type.ERROR;
    }
    
    @Override
    public Type visitBoolLiter_Expr(@NotNull BasicParser.BoolLiter_ExprContext ctx) {
        if (ctx.start.getType() == BasicParser.BOOL) {
            return Type.BOOL;
        }
        System.exit(200); return Type.ERROR;
    }
    
    @Override
    public Type visitIntLiter_Expr(@NotNull BasicParser.IntLiter_ExprContext ctx) {
        return Type.INT;
    }
    
    @Override
    public Type visitCharLiter_Expr(@NotNull BasicParser.CharLiter_ExprContext ctx) {
        return Type.CHAR;
    }
    
    @Override
    public Type visitStrLiter_Expr(@NotNull BasicParser.StrLiter_ExprContext ctx) {
        return Type.STRING;
    }
    
    @Override
    public Type visitPairLiter_Expr(@NotNull BasicParser.PairLiter_ExprContext ctx) {
        return Type.NULL;
    }
    
    @Override
    public Type visitIdent_Expr(@NotNull BasicParser.Ident_ExprContext ctx) {
        return Type.IDENT;
    }

    @Override
    public Type visitArglist(BasicParser.ArglistContext ctx) {
        if (ctx.expr().size() == ctx.COMMA().size() + 1) {
            return Type.NULL;
        }
        System.exit(200);
        return Type.NULL;
    }
    
    
    @Override
    public Type visitPair_pairElemType(@NotNull BasicParser.Pair_pairElemTypeContext ctx) {
        return Type.PAIR;
    }
    
    @Override
    public Type visitBaseType_pairElemType(@NotNull BasicParser.BaseType_pairElemTypeContext ctx) {
        return visit(ctx.basetype());
    }

    @Override
    public Type visitPairelem(BasicParser.PairelemContext ctx) {
        return visit(ctx.expr());
    }
    
    
}


	
}



